import numpy as np
from utils.utils import get_keys, get_rest_by_id
from rsalgos.ressys_nearest_neighbour import RecSysNearestActions
from config.ConfigDataProvider import config_data


class ExplorationPolicy(object):

    def __init__(self):
        self.restaurant_indices = None
        self.rest_contextual_matrix = None
        self.recommended_list = list()
        self.reset_suggestions()
        print('rest contextual matrix created with shape ', self.rest_contextual_matrix.shape)

    def reset_suggestions(self):
        self.restaurant_indices = get_keys().copy()
        self.rest_contextual_matrix = np.asarray([get_rest_by_id(each) for each in self.restaurant_indices])
        # print('resetting the recommended_list of size --', self.recommended_list)
        self.recommended_list = list()

    def get_suggestions_matrix(self, indexes=None):
        # print('length of recommended list {}--{}--{}'.format(self.recommended_list, indexes, len(self.restaurant_indices)))
        if indexes:
            query_i = [idx for idx in indexes if idx not in self.recommended_list]
        else:
            query_i = [idx for idx, rest_idx in enumerate(self.restaurant_indices)
                       if idx not in self.recommended_list]

        if len(query_i) == 0:
            print('case when recommendations matches provided list')
            actions_matrix = self.rest_contextual_matrix[indexes]
            query_i = indexes
            self.recommended_list = list()
        else:
            actions_matrix = self.rest_contextual_matrix[query_i]
        # print('length of matrix returned back from suggestions {}--{}'.format(len(query_i), actions_matrix.shape))
        return actions_matrix, query_i

    def get_random_action(self, indexes=None):
        if indexes:
            actions_matrix, query_i = self.get_suggestions_matrix(indexes)
        else:
            actions_matrix, query_i = self.get_suggestions_matrix()
        i = np.random.choice(actions_matrix.shape[0])
        self.recommended_list.append(query_i[i])
        return actions_matrix[i].reshape(-1)

    def get_action(self, current_state, model):
        # by default random policy with removing item from recommended list
        return self.get_random_action(), 0.0


class EpsilonGreedy(ExplorationPolicy):

    def __init__(self):
        ExplorationPolicy.__init__(self)
        self.epsilon = float(config_data.get_config_value('EPSILON-GREEDY', 'epsilon.max'))
        self.epsilon_min = float(config_data.get_config_value('EPSILON-GREEDY', 'epsilon.min'))
        self.epsilon_decay = float(config_data.get_config_value('EPSILON-GREEDY', 'epsilon.decay'))
        self.query_size = int(config_data.get_config_value('EPSILON-GREEDY', 'query.size'))
        self.default_q_value = 0

    def get_action(self, current_state, model):
        if np.random.rand() <= self.epsilon:
            return self.get_random_action(), self.default_q_value
        else:
            all_action_mat, query_i = self.get_suggestions_matrix()
            action, maxq_value, idx = self.__get_action_model(current_state, all_action_mat, model)
            self.recommended_list.append(query_i[int(idx)])
            return action, maxq_value

    def update_epsilon(self, episode_count):
        if self.epsilon > self.epsilon_min:
            self.epsilon = np.exp(-self.epsilon_decay * episode_count)

    def __generator_dict(self, current_state, all_actions_matrix):
        state_size = current_state.shape[0]
        context_feat_dim = current_state.shape[1]
        for index in range(0, all_actions_matrix.shape[0], self.query_size):
            x_action_input = all_actions_matrix[index:index + self.query_size]
            x_state_input = np.zeros((x_action_input.shape[0], state_size, context_feat_dim))
            for i in range(x_action_input.shape[0]):
                x_state_input[i, :, :] = current_state
            yield [x_state_input, x_action_input]

    def __get_action_model(self, current_state, all_action_mat, model):
        gen_func = self.__generator_dict(current_state, all_action_mat)
        output = np.zeros((all_action_mat.shape[0],1))
        for index in range(0, all_action_mat.shape[0], self.query_size):
            model_input = next(gen_func)
            q_value_matrix = model.predict(model_input)
            output[index:index + self.query_size] = q_value_matrix

        idx = np.argmax(output)
        return all_action_mat[idx].reshape(-1), output[idx].reshape(-1), idx


class NearestNeighbourEpsilon(ExplorationPolicy):

    def __init__(self, state_space, context_feat_dim, recom_length, hyper_param):
        ExplorationPolicy.__init__(self)
        self.epsilon = float(config_data.get_config_value('NN-EPSILON-GREEDY', 'epsilon.max'))
        self.epsilon_min = float(config_data.get_config_value('NN-EPSILON-GREEDY', 'epsilon.min'))
        self.epsilon_decay = float(config_data.get_config_value('NN-EPSILON-GREEDY', 'epsilon.decay'))
        self.default_q_value = 0
        self.recom_length = recom_length
        self.state_size = state_space
        self.context_feat_dim = context_feat_dim

        self.nn_class = RecSysNearestActions()
        self.nn_class.train_nearest_neighbour(self.rest_contextual_matrix, self.recom_length)

        self.noise_class = OUNoise(context_feat_dim, theta=hyper_param)  # TODO: state_space*context_feat_dim

    def get_action(self, current_state, model):
        # all_indexes = list()
        # current_state_ou = current_state + self.noise_class.noise().reshape(self.state_size, self.context_feat_dim)
        # for state_temp in current_state_ou:
        #     # curr_state_query = np.multiply(state_temp, np.random.normal(0, 0.5, [self.context_feat_dim, ]))
        #     # get nearest neighbours from the current state
        #     indexes, _ = self.nn_class.get_nearest_neighbours(state_temp, self.recom_length)
        #     all_indexes.extend(indexes)
        state_temp = np.mean(current_state, axis=0) + self.noise_class.noise()
        all_indexes, _ = self.nn_class.get_nearest_neighbours(state_temp, self.recom_length)

        if np.random.rand() <= self.epsilon:
            return self.get_random_action(all_indexes), self.default_q_value
        else:
            all_indexes_matrix, query_i = self.get_suggestions_matrix(all_indexes)
            action, maxq_value, idx = self.__get_nn_action(all_indexes_matrix, current_state, model)
            self.recommended_list.append(query_i[int(idx)])
            return action, maxq_value

    def update_epsilon(self, episode_count):
        if self.epsilon > self.epsilon_min:
            self.epsilon = np.exp(-self.epsilon_decay * episode_count)

    def __get_nn_action(self, all_indexes_matrix, current_state, model):
        x_state_input = np.zeros((all_indexes_matrix.shape[0], self.state_size, self.context_feat_dim))
        for i in range(all_indexes_matrix.shape[0]):
            x_state_input[i, :, :] = current_state

        q_value_matrix = model.predict([x_state_input, all_indexes_matrix])
        idx = np.argmax(q_value_matrix)
        return all_indexes_matrix[idx].reshape(-1), q_value_matrix[idx].reshape(-1), idx


class LinUCB(ExplorationPolicy):

    def __init__(self, state_space, context_feat_dim):
        ExplorationPolicy.__init__(self)
        self.state_size = state_space
        self.context_feat_dim = context_feat_dim

    def get_action(self, current_state, model):
        # TODO: get the actions using contextual UCB algorithm
        pass


class OUNoise:

    def __init__(self, a_dim, mu=0, theta=0.5, sigma=0.2):
        self.a_dim = a_dim
        self.mu = mu
        self.theta = theta
        self.sigma = sigma
        self.state = np.ones(self.a_dim) * self.mu
        self.reset()

    def reset(self):
        self.state = np.ones(self.a_dim) * self.mu

    def noise(self):
        x = self.state
        dx = self.theta * (self.mu - x) + self.sigma * np.random.rand(len(x))
        self.state = x + dx
        return self.state
